
















<!DOCTYPE html>
<html lang='en-us'><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <link rel="shortcut icon" href='http://localhost:1313/favicon.ico' type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Towards Fast IO on Linux using Rust - Opdroids Tech Journal</title>

    

    

    

    
        <meta property="og:url" content="http://localhost:1313/posts/rust-io/">
  <meta property="og:site_name" content="Opdroids Tech Journal">
  <meta property="og:title" content="Towards Fast IO on Linux using Rust">
  <meta property="og:description" content="We will be trying to compare various different ways of reading a file using Rust. Apart from &#34;wc -l&#34; we will be running each function 10 times using criterion and then picking the mean.
Code for the following benchmarks lives at Benchmark code for Linux IO using Rust. In the following code BUFFER_SIZE was 8192 and NUM_BUFFERS was 32.
Details about the machine Framework 16 with 7840hs and 64 Gigs of RAM.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-03T23:13:02-04:00">
    <meta property="article:modified_time" content="2024-07-03T23:13:02-04:00">

    

    
        
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Towards Fast IO on Linux using Rust">
  <meta name="twitter:description" content="We will be trying to compare various different ways of reading a file using Rust. Apart from &#34;wc -l&#34; we will be running each function 10 times using criterion and then picking the mean.
Code for the following benchmarks lives at Benchmark code for Linux IO using Rust. In the following code BUFFER_SIZE was 8192 and NUM_BUFFERS was 32.
Details about the machine Framework 16 with 7840hs and 64 Gigs of RAM.">

    <link rel="stylesheet" href="/style.css" integrity="">





    
    <script>
        if (!('theme' in localStorage)) {
            localStorage.theme = 'light';
        }

        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.setAttribute("data-theme", "dark");
        } else {
            document.documentElement.setAttribute("data-theme", "light");
        }
    </script>
<script defer src="/js/header.js" integrity=""></script>



    <script defer src="/js/zooming.js" integrity=""></script>







    
        
        
            <script defer src="/js/builtin-copy.js" integrity=""></script>
        
    



    
    
    
    <script defer src="/js/search-en-us.js" integrity=""></script>






    
</head>
<body><header>
    <div id="header_left">
        <div id="sidebar_btn">
            <input type="checkbox" id="sidebar_btn_input" class="hidden" />
            <label id="sidebar_btn_label" for="sidebar_btn_input">
                <svg id="menu_icon" width="26px" height="26px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
</svg>

</svg>
            </label>
            <label id="sidebar_canvas_overlay_wrapper" for="sidebar_btn_input">
                <div id="sidebar_canvas_overlay"></div>
            </label>
            <div id="sidebar">
                <ul></ul>
            </div>
        </div>
    
        <div class="brand">
            <div>
                <a href="/">Opdroids Tech Journal</a>
            </div>
        </div>
    </div>

    <div class="toolbox">
        <div id="theme_tool">
            <svg id="dark_mode_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

</svg>
            <svg id="light_mode_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
</svg>

</svg>
        </div>

        
            <div id="search_tool">
                <svg id="search_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
</svg>

</svg>
            </div>
        

        <div id="rss_tool">
            <svg id="rss_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
</svg>

</svg>
        </div>

        
    </div>
</header>
<nav id="navbar" class="pure-menu">
    <ul class="pure-menu-list"></ul>
</nav>
<main>
            <div id="content" class="content-margin">
                <h1>Towards Fast IO on Linux using Rust</h1>


    
    <div class="collapsible-menu-wrapper"><div class="collapsible-menu-type"><span>Table of contents</span></div><div class="collapsible-menu">
        
            <nav id="TableOfContents">
<ul>
<li><a href="#headline-1">Details about the machine</a>
</li>
<li><a href="#headline-2">Details about the text file</a>
</li>
<li><a href="#headline-3">For the impatient: an overview of the results</a>
<ul>
<li><a href="#headline-4">Thanks to these fine folks</a>
</li>
<li><a href="#headline-5">Baseline: wc -l</a>
</li>
<li><a href="#headline-6">Method 1: Read the file using BufReader and use reader.lines().count()</a>
</li>
<li><a href="#headline-7">Method 2: Read the file using BufReader and avoid string appends</a>
</li>
<li><a href="#headline-8">Method 3: Read the file using Direct IO</a>
</li>
<li><a href="#headline-9">Method 4: Read the file using Mmap</a>
</li>
<li><a href="#headline-10">Method 5: Read the file using Mmap and AVX2</a>
</li>
<li><a href="#headline-11">Method 6: Read the file using Mmap and AVX512</a>
</li>
<li><a href="#headline-12">Method 7: Read the file using Vectored IO</a>
</li>
<li><a href="#headline-13">Method 8: Read the file using io_uring</a>
</li>
<li><a href="#headline-14">Method 9: Read the file using io_uring with vectored IO</a>
</li>
</ul>
</li>
</ul>
</nav>
        
    </div></div>



    <div class="content-margin">



<article class="line-numbers">
    
    
    
<p>
<div class="icon">
    
        <div>
    
        
            
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
</svg>


        
    
        </div>
    
</div>
  </p>
<p>
We will be trying to compare various different ways of reading a file using Rust.
Apart from &#34;wc -l&#34; we will be running each function 10 times using criterion and then picking the mean.</p>
<p>
Code for the following benchmarks lives at
<a href="https://github.com/deepankarsharma/shatranj/blob/main/benches/bench.rs">Benchmark code for Linux IO using Rust</a>.
In the following code BUFFER_SIZE was 8192 and NUM_BUFFERS was 32.</p>
<div id="outline-container-headline-1" class="outline-3">
<h3 id="headline-1">
Details about the machine
</h3>
<div id="outline-text-headline-1" class="outline-text-3">
<ol>
<li>Framework 16 with 7840hs and 64 Gigs of RAM. Power plugged in and performance mode enabled.</li>
<li>SSD: WD_BLACK SN850X 4000GB. Test using Gnome Disks shows the read speed at 3.6 GB/s (Sample size 1000MB, 100 Samples).</li>
<li>Filesystem : btrfs</li>
<li>Uname string: Linux fedora 6.8.8-300.fc40.x86_64 #1 SMP PREEMPT_DYNAMIC Sat Apr 27 17:53:31 UTC 2024 x86_64 GNU/Linux</li>
</ol>
</div>
</div>
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
Details about the text file
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<p>Uncompressed size: 22G
Number of lines: 200,000,000
Compressed size after btrfs compression (zstd): 5.3G</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
For the impatient: an overview of the results
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<figure>
<div class="table-block">
<table class="mc-table">
<thead>
<tr>
<th>Method</th>
<th class="align-right">Time (seconds)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mmap with AVX512</td>
<td class="align-right">2.61</td>
</tr>
<tr>
<td>Mmap with AVX2</td>
<td class="align-right">2.64</td>
</tr>
<tr>
<td>io_uring with Vectored IO</td>
<td class="align-right">2.86</td>
</tr>
<tr>
<td>Vectored IO</td>
<td class="align-right">2.89</td>
</tr>
<tr>
<td>Mmap</td>
<td class="align-right">3.43</td>
</tr>
<tr>
<td>io_uring</td>
<td class="align-right">5.26</td>
</tr>
<tr>
<td>wc -l (baseline)</td>
<td class="align-right">8.01</td>
</tr>
<tr>
<td>Direct IO</td>
<td class="align-right">10.56</td>
</tr>
<tr>
<td>BufReader without appends</td>
<td class="align-right">15.94</td>
</tr>
<tr>
<td>BufReader with lines().count()</td>
<td class="align-right">33.50</td>
</tr>
</tbody>
</table>
</div>
<figcaption>
Benchmark results
</figcaption>
</figure>
<p>
Interesting observation was that AVX512 was taking 2.61 seconds, file is ~22G and SSD benchmarks show 3.6 GB/s read speed. This means that the file should be read in about 6 seconds. The AVX512 implementation is reading the file at about 8.4 GB/s. What gives? Turns out Fedora uses btrfs which enables zstd compression by default. Actual on disk size can be found using compsize.</p>
<div class="src src-bash">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>opdroid@box:~/tmp$ sudo compsize data 
</span></span><span style="display:flex;"><span>Processed <span style="color:#ae81ff">1</span> file, <span style="color:#ae81ff">177437</span> regular extents <span style="color:#f92672">(</span><span style="color:#ae81ff">177437</span> refs<span style="color:#f92672">)</span>, <span style="color:#ae81ff">0</span> inline.
</span></span><span style="display:flex;"><span>Type       Perc     Disk Usage   Uncompressed Referenced  
</span></span><span style="display:flex;"><span>TOTAL       24%      5.3G          21G          21G       
</span></span><span style="display:flex;"><span>none       100%       32K          32K          32K       
</span></span><span style="display:flex;"><span>zstd        24%      5.3G          21G          21G</span></span></code></pre></div>
</div>
<div id="outline-container-headline-4" class="outline-4">
<h4 id="headline-4">
Thanks to these fine folks
</h4>
<div id="outline-text-headline-4" class="outline-text-4">
<ol>
<li><a href="https://twitter.com/alextjensen/status/1787939676977860809">@alextjensen</a> - for pointing me to sane defaults for BufReader and to compile to the native arch.</li>
<li><a href="https://twitter.com/aepau2/status/1787947525799841990">@aepau2</a> - for spotting a glaring error in the wc numbers. I had forgotten to drop the cache before measuring with wc. </li>
<li><a href="https://twitter.com/rflaherty71/status/1787941794560278619">@rflaherty71</a> - for pointing me to use more buffers which are larger (64 x 64k). </li>
<li><a href="https://twitter.com/daniel_c0deb0t/status/1787927328330567962">@daniel_c0deb0t</a> - for pointing me to use larger buffers.</li>
</ol>
<p>Always a good idea to use some code we did not write as a baseline.</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-4">
<h4 id="headline-5">
Baseline: wc -l
</h4>
<div id="outline-text-headline-5" class="outline-text-4">
<div class="src src-bash">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  opdroid@box:~/tmp$ time wc -l data
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">200000000</span> data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  real	0m8.010s
</span></span><span style="display:flex;"><span>  user	0m0.193s
</span></span><span style="display:flex;"><span>  sys	0m7.591s</span></span></code></pre></div>
</div>
<p>
We reset the file caches using the following command at the end of each function. I am yet to figure out how to use a teardown function in criterion so that this doesnt get counted in the time taken.</p>
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// TODO: move to a teardown function in criterion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">reset_file_caches</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Execute the command to reset file caches
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> output <span style="color:#f92672">=</span> Command::new(<span style="color:#e6db74">&#34;sudo&#34;</span>)
</span></span><span style="display:flex;"><span>        .arg(<span style="color:#e6db74">&#34;sh&#34;</span>)
</span></span><span style="display:flex;"><span>        .arg(<span style="color:#e6db74">&#34;-c&#34;</span>)
</span></span><span style="display:flex;"><span>        .arg(<span style="color:#e6db74">&#34;echo 3 &gt; /proc/sys/vm/drop_caches&#34;</span>)
</span></span><span style="display:flex;"><span>        .output()
</span></span><span style="display:flex;"><span>        .expect(<span style="color:#e6db74">&#34;Failed to reset file caches&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check if the command executed successfully
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>output.status.success() {
</span></span><span style="display:flex;"><span>        panic!(<span style="color:#e6db74">&#34;Failed to reset file caches: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, output);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-4">
<h4 id="headline-6">
Method 1: Read the file using BufReader and use reader.lines().count()
</h4>
<div id="outline-text-headline-6" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_newlines_standard</span>(filename: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, std::io::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(filename)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> BufReader::with_capacity(<span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>, file);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> newline_count <span style="color:#f92672">=</span> reader.lines().count();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    reset_file_caches();
</span></span><span style="display:flex;"><span>    Ok(newline_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 36.5 seconds on my machine.</p>
<p><img src="/images/flamegraph_count_newlines_standard.png" alt="/images/flamegraph_count_newlines_standard.png" title="/images/flamegraph_count_newlines_standard.png" /></p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-4">
<h4 id="headline-7">
Method 2: Read the file using BufReader and avoid string appends
</h4>
<div id="outline-text-headline-7" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_newlines_standard_non_appending</span>(filename: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, std::io::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(filename)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> reader <span style="color:#f92672">=</span> BufReader::with_capacity(<span style="color:#ae81ff">64</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>, file);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> newline_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> buffer <span style="color:#f92672">=</span> reader.fill_buf()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> buffer.is_empty() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            newline_count <span style="color:#f92672">+=</span> buffer.iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>).count();
</span></span><span style="display:flex;"><span>            buffer.len()
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        reader.consume(len);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    reset_file_caches();
</span></span><span style="display:flex;"><span>    Ok(newline_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 15.94 seconds on my machine. This is less than half of the appending version.</p>
<p>
When we look at the flamegraph we can verify that the appends are gone.</p>
<p><img src="/images/flamegraph_count_newlines_standard_non_appending.svg" alt="/images/flamegraph_count_newlines_standard_non_appending.svg" title="/images/flamegraph_count_newlines_standard_non_appending.svg" /></p>
</div>
</div>
<div id="outline-container-headline-8" class="outline-4">
<h4 id="headline-8">
Method 3: Read the file using Direct IO
</h4>
<div id="outline-text-headline-8" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_newlines_direct_io</span>(filename: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> open_options <span style="color:#f92672">=</span> File::options();
</span></span><span style="display:flex;"><span>    open_options.read(<span style="color:#66d9ef">true</span>).custom_flags(libc::<span style="color:#66d9ef">O_DIRECT</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> file <span style="color:#f92672">=</span> open_options.open(filename)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">0</span>; <span style="color:#66d9ef">BUFFER_SIZE</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> newline_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> bytes_read <span style="color:#f92672">=</span> file.read(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buffer)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> bytes_read <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> chunk_newline_count <span style="color:#f92672">=</span> buffer[<span style="color:#f92672">..</span>bytes_read].iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>).count();
</span></span><span style="display:flex;"><span>        newline_count <span style="color:#f92672">+=</span> chunk_newline_count;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    reset_file_caches();
</span></span><span style="display:flex;"><span>    Ok(newline_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 35.7 seconds on my machine.</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-4">
<h4 id="headline-9">
Method 4: Read the file using Mmap
</h4>
<div id="outline-text-headline-9" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_newlines_memmap</span>(filename: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(filename)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> mmap <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { Mmap::map(<span style="color:#f92672">&amp;</span>file)<span style="color:#f92672">?</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> newline_count <span style="color:#f92672">=</span> mmap.iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>).count();
</span></span><span style="display:flex;"><span>    reset_file_caches();
</span></span><span style="display:flex;"><span>    Ok(newline_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 8.3 seconds on my machine.</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-4">
<h4 id="headline-10">
Method 5: Read the file using Mmap and AVX2
</h4>
<div id="outline-text-headline-10" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_newlines_memmap_avx2</span>(filename: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(filename)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> mmap <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { Mmap::map(<span style="color:#f92672">&amp;</span>file)<span style="color:#f92672">?</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> newline_byte <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> newline_vector <span style="color:#f92672">=</span> _mm256_set1_epi8(newline_byte <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i8</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> newline_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> ptr <span style="color:#f92672">=</span> mmap.as_ptr();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> end_ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { ptr.add(mmap.len()) };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ptr <span style="color:#f92672">&lt;=</span> end_ptr.sub(<span style="color:#ae81ff">32</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { _mm256_loadu_si256(ptr <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> __m256i) };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cmp_result <span style="color:#f92672">=</span> _mm256_cmpeq_epi8(data, newline_vector);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> mask <span style="color:#f92672">=</span> _mm256_movemask_epi8(cmp_result);
</span></span><span style="display:flex;"><span>        newline_count <span style="color:#f92672">+=</span> mask.count_ones() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>        ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { ptr.add(<span style="color:#ae81ff">32</span>) };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Count remaining bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> remaining_bytes <span style="color:#f92672">=</span> end_ptr <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span> <span style="color:#f92672">-</span> ptr <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>    newline_count <span style="color:#f92672">+=</span> mmap[mmap.len() <span style="color:#f92672">-</span> remaining_bytes<span style="color:#f92672">..</span>].iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> newline_byte).count();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    reset_file_caches();
</span></span><span style="display:flex;"><span>    Ok(newline_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 2.64 seconds on my machine.</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-4">
<h4 id="headline-11">
Method 6: Read the file using Mmap and AVX512
</h4>
<div id="outline-text-headline-11" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_newlines_memmap_avx512</span>(filename: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(filename)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> mmap <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { Mmap::map(<span style="color:#f92672">&amp;</span>file)<span style="color:#f92672">?</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> newline_byte <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> newline_vector <span style="color:#f92672">=</span> _mm512_set1_epi8(newline_byte <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i8</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> newline_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> ptr <span style="color:#f92672">=</span> mmap.as_ptr();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> end_ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { ptr.add(mmap.len()) };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ptr <span style="color:#f92672">&lt;=</span> end_ptr.sub(<span style="color:#ae81ff">64</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { _mm512_loadu_si512(ptr <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">i32</span>) };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cmp_result <span style="color:#f92672">=</span> _mm512_cmpeq_epi8_mask(data, newline_vector);
</span></span><span style="display:flex;"><span>        newline_count <span style="color:#f92672">+=</span> cmp_result.count_ones() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>        ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { ptr.add(<span style="color:#ae81ff">64</span>) };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Count remaining bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> remaining_bytes <span style="color:#f92672">=</span> end_ptr <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span> <span style="color:#f92672">-</span> ptr <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>    newline_count <span style="color:#f92672">+=</span> mmap[mmap.len() <span style="color:#f92672">-</span> remaining_bytes<span style="color:#f92672">..</span>].iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> newline_byte).count();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    reset_file_caches();
</span></span><span style="display:flex;"><span>    Ok(newline_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 2.61 seconds on my machine.</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-4">
<h4 id="headline-12">
Method 7: Read the file using Vectored IO
</h4>
<div id="outline-text-headline-12" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_newlines_vectored_io</span>(path: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, Error<span style="color:#f92672">&gt;</span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> file <span style="color:#f92672">=</span> File::open(path)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffers_: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">16</span>).map(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> vec![<span style="color:#ae81ff">0</span>; <span style="color:#66d9ef">BUFFER_SIZE</span>]).collect();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffers: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> buffers_.iter_mut().map(<span style="color:#f92672">|</span>buf<span style="color:#f92672">|</span> io::IoSliceMut::new(buf)).collect();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> newline_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> bytes_read <span style="color:#f92672">=</span> file.read_vectored(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buffers)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> bytes_read <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Calculate how many buffers were filled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> filled_buffers <span style="color:#f92672">=</span> bytes_read <span style="color:#f92672">/</span> <span style="color:#66d9ef">BUFFER_SIZE</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Process the fully filled buffers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> buf <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>buffers[<span style="color:#f92672">..</span>filled_buffers] {
</span></span><span style="display:flex;"><span>            newline_count <span style="color:#f92672">+=</span> buf.iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>).count();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Handle the potentially partially filled last buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> filled_buffers <span style="color:#f92672">&lt;</span> buffers.len() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> last_buffer <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>buffers[filled_buffers];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> end <span style="color:#f92672">=</span> bytes_read <span style="color:#f92672">%</span> <span style="color:#66d9ef">BUFFER_SIZE</span>;
</span></span><span style="display:flex;"><span>            newline_count <span style="color:#f92672">+=</span> last_buffer[<span style="color:#f92672">..</span>end].iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>).count();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Ok(newline_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 7.7 seconds on my machine.</p>
</div>
</div>
<div id="outline-container-headline-13" class="outline-4">
<h4 id="headline-13">
Method 8: Read the file using io_uring
</h4>
<div id="outline-text-headline-13" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_lines_io_uring</span>(path: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(path)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> fd <span style="color:#f92672">=</span> file.as_raw_fd();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> ring <span style="color:#f92672">=</span> IoUring::new(<span style="color:#ae81ff">8</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> line_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> read_size <span style="color:#f92672">=</span> buf.len();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sqe <span style="color:#f92672">=</span> opcode::Read::new(types::Fd(fd), buf.as_mut_ptr(), read_size <span style="color:#66d9ef">as</span> _)
</span></span><span style="display:flex;"><span>            .offset(offset <span style="color:#66d9ef">as</span> _)
</span></span><span style="display:flex;"><span>            .build()
</span></span><span style="display:flex;"><span>            .user_data(line_count <span style="color:#66d9ef">as</span> _);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            ring.submission()
</span></span><span style="display:flex;"><span>                .push(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> sqe)
</span></span><span style="display:flex;"><span>                .expect(<span style="color:#e6db74">&#34;submission queue is full&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ring.submit_and_wait(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cqe <span style="color:#f92672">=</span> ring.completion().next().expect(<span style="color:#e6db74">&#34;completion queue is empty&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> bytes_read <span style="color:#f92672">=</span> cqe.result() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>        line_count <span style="color:#f92672">=</span> cqe.user_data() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> bytes_read <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>buf[<span style="color:#f92672">..</span>bytes_read];
</span></span><span style="display:flex;"><span>        line_count <span style="color:#f92672">+=</span> data.iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>).count();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">+=</span> bytes_read <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u64</span>;
</span></span><span style="display:flex;"><span>        read_size <span style="color:#f92672">=</span> (buf.len() <span style="color:#f92672">-</span> (offset <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span> <span style="color:#f92672">%</span> buf.len())) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Ok(line_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 10.5 seconds on my machine.</p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-4">
<h4 id="headline-14">
Method 9: Read the file using io_uring with vectored IO
</h4>
<div id="outline-text-headline-14" class="outline-text-4">
<div class="src src-rust">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_lines_io_uring_vectored</span>(path: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(path)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> fd <span style="color:#f92672">=</span> file.as_raw_fd();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> ring <span style="color:#f92672">=</span> IoUring::new(<span style="color:#66d9ef">NUM_BUFFERS</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> line_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffers <span style="color:#f92672">=</span> vec![vec![<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">8192</span>]; <span style="color:#66d9ef">NUM_BUFFERS</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> iovecs: Vec<span style="color:#f92672">&lt;</span>iovec<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> buffers
</span></span><span style="display:flex;"><span>        .iter_mut()
</span></span><span style="display:flex;"><span>        .map(<span style="color:#f92672">|</span>buf<span style="color:#f92672">|</span> iovec {
</span></span><span style="display:flex;"><span>            iov_base: <span style="color:#a6e22e">buf</span>.as_mut_ptr() <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> _,
</span></span><span style="display:flex;"><span>            iov_len: <span style="color:#a6e22e">buf</span>.len(),
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        .collect();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sqe <span style="color:#f92672">=</span> opcode::Readv::new(types::Fd(fd), iovecs.as_mut_ptr(), iovecs.len() <span style="color:#66d9ef">as</span> _)
</span></span><span style="display:flex;"><span>            .offset(offset <span style="color:#66d9ef">as</span> _)
</span></span><span style="display:flex;"><span>            .build()
</span></span><span style="display:flex;"><span>            .user_data(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            ring.submission()
</span></span><span style="display:flex;"><span>                .push(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> sqe)
</span></span><span style="display:flex;"><span>                .expect(<span style="color:#e6db74">&#34;submission queue is full&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ring.submit_and_wait(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cqe <span style="color:#f92672">=</span> ring.completion().next().expect(<span style="color:#e6db74">&#34;completion queue is empty&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> bytes_read <span style="color:#f92672">=</span> cqe.result() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> bytes_read <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffer_line_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> remaining_bytes <span style="color:#f92672">=</span> bytes_read;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> buf <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>buffers[<span style="color:#f92672">..</span>iovecs.len()] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> buf_size <span style="color:#f92672">=</span> buf.len();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> data_size <span style="color:#f92672">=</span> remaining_bytes.min(buf_size);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>buf[<span style="color:#f92672">..</span>data_size];
</span></span><span style="display:flex;"><span>            buffer_line_count <span style="color:#f92672">+=</span> data.iter().filter(<span style="color:#f92672">|&amp;&amp;</span>b<span style="color:#f92672">|</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;\n&#39;</span>).count();
</span></span><span style="display:flex;"><span>            remaining_bytes <span style="color:#f92672">-=</span> data_size;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> remaining_bytes <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        line_count <span style="color:#f92672">+=</span> buffer_line_count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">+=</span> bytes_read <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u64</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(line_count)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<p>
This takes about 7.6 seconds on my machine.</p>
</div>
</div>
</div>
</div>

</article>
</div>


                
                    
                
            </div>
        </main>
</body>
</html>
